-> To understand the concept of how a CPU works, it is necessary to have some knowledge of assembly language, because this is the language that the CPU understands.
-> To understand the memory concept, consider writing something on paper. We write from top to bottom line by line. Similarly, the data is written on the RAM. Each line on the paper has a number assigned, similarly, there is an address on the memory which is in the form of hexadecimal, decimal, or binary.
-> We are given 8-32 global variables to work with, and they are called registers. Our CPU contains the number of registers depending on its architecture. We can perform any type of functionality on these variables.
-> If we have a 32-bit machine, we can write a maximum of 32 bits on a register and similarly for a 64-bit machine. If we want to write more data, we have to expand it through our code.
-> In these registers, we have different registers. Some of these are special ones. The most special one is the program counter register (RIP: Instruction Pointer / RPC: Program Counter) that instructs which program we will execute next. Every time we start a program, its value is incremented.
-> It has the total number of lines that have to be executed. It points to the next line to be executed. When it is executed, it moves to the next line.
	learned more about the different types of registers from GPT:-
	=> General-purpose registers (e.g., EAX, EBX, ECX, EDX in 32-bit mode, or RAX, RBX, RCX, RDX in 64-bit mode)
	=> Index and pointer registers (e.g., ESI, EDI, EBP, ESP)
	=> Instruction Pointer (EIP in 32-bit or RIP in 64-bit mode)
	=> Flag register (EFLAGS or RFLAGS), which stores the results of operations (like overflow or zero flags)
-> Virtually all computations are expressed in terms of simple operations on registers.
-> Real progress needs many more than 32-bit variables to work with. e.g. we are making a Super Mario game in assembly, we will definitely need more space to store the coins gathered by the player.
-> Some General Purpose Registers:
	=> eax (Accumulator Register): Primarily used for arithmetic operations and storing function return values.
	=> ebx (Base Register): Often used to hold memory addresses for data structures or as general-purpose storage.
	=> ecx (Counter Register): Commonly used as a loop counter for iterations and loops.
	=> edx (Data Register): Used for input/output operations and extending arithmetic results (e.g., multiplication and division).
-> We can access memory in assembly through two methods:
	=> Loads and Stores at Addresses: This means accessing memory using direct memory addresses, like accessing an array where each element has its own address in memory.
	=> PUSH and POP operations on a Stack: This refers to using the stack for memory storage. You can use the PUSH operation to place values onto the stack and the POP operation to retrieve them. This is particularly useful for temporarily storing data or for managing function calls.
-> We have a special pointer that points at the top of the stack, which is called Stack Pointer (SP/ ESP/ RSP). When we use push and pop operations in the stack while maintaining the memory, the values of the eax and ebx and other registers that are being used are updated accordingly. An example process is present in the relevant screenshot.
-> The memory in the stack is maintained from bottom to top. So whenever we push or pop data, it is done on the top of the lowest index of the memory.
-> Memory is for assembly programs while the disk is for Ruby or Python or any other programming language. We pull the variables, we work on them and then we put them back into memory. We should not use the memory too often because whatever we do with the memory is cached near the CPU.
-> Control flow is done via GOTOs; jump, branch, or call. The purpose of this is to alter the program counter directly.
-> jmp is an unconditional statement. Whenever we encounter jump, we will always follow it.
-> Most operations are condition dependent. Branches are conditional jump statements that are predicated on a status code. e.g. if the status is zero then move to this statement.
	branch (if) equal to zero == beq
	jump (if) equal / zero == je, jz
-> A call is just an unconditional goto that pushes the next address on the stack so a RET instruction can later pop it off and keep going where the call left off. (The RET (return) instruction in assembly is used to return control to the calling function or procedure by popping the return address off the stack.)
-> The difference in jump and call is that whenever we make a jump statement, we have to specify the exact address where we want to jump. Here, we do not have the track from where we came so if we want to go to the previous instruction again, we have to specify the path. To avoid this thing, we use call statement that automatically returns to the statement from where the call was called. The stack of the memory is also updated with the current addresses and others, accordingly whenever the call is called and whenever it returns
-> The CPU reads instructions in only numbers. So whenever we write any statement in assembly, it is also read in the form of a number. The sample is given in the relevant picture in the project.